<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Snake</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Arial', sans-serif;
      background: linear-gradient(135deg, #2ecc71 0%, #27ae60 100%);
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
      padding: 20px;
    }

    #game {
      display: flex;
      gap: 30px;
      background: rgba(255, 255, 255, 0.1);
      padding: 30px;
      border-radius: 15px;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
    }

    canvas {
      border: 3px solid #333;
      background: #000;
      border-radius: 5px;
    }

    #ui {
      display: flex;
      flex-direction: column;
      gap: 20px;
      color: white;
      min-width: 200px;
    }

    #score, #high-score, #speed, #controls {
      background: rgba(255, 255, 255, 0.1);
      padding: 15px;
      border-radius: 8px;
      text-align: center;
    }

    #score {
      font-size: 24px;
      font-weight: bold;
    }

    #high-score {
      font-size: 18px;
      font-weight: bold;
      color: #f1c40f;
    }

    #speed {
      font-size: 18px;
      font-weight: bold;
    }

    #controls {
      font-size: 14px;
      line-height: 1.6;
    }

    #game-over {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0, 0, 0, 0.9);
      color: white;
      padding: 40px;
      border-radius: 15px;
      text-align: center;
      display: none;
    }

    #game-over h2 {
      font-size: 48px;
      margin-bottom: 20px;
    }

    #game-over button {
      margin-top: 20px;
      padding: 15px 40px;
      font-size: 18px;
      background: #2ecc71;
      color: white;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      transition: background 0.3s;
    }

    #game-over button:hover {
      background: #27ae60;
    }

    #pause-overlay {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0, 0, 0, 0.85);
      color: white;
      padding: 40px 60px;
      border-radius: 15px;
      text-align: center;
      display: none;
      font-size: 48px;
      font-weight: bold;
      letter-spacing: 3px;
    }
  </style>
</head>
<body>
  <div id="game">
    <canvas id="board" width="600" height="600"></canvas>
    <div id="ui">
      <div id="score">Score: 0</div>
      <div id="high-score">High Score: 0</div>
      <div id="speed">Speed: 1</div>
      <div id="controls">
        ← → ↑ ↓ Move<br>
        Space Speed Boost<br>
        P/Esc Pause<br>
        R Restart
      </div>
    </div>
  </div>

  <div id="pause-overlay">PAUSED</div>

  <div id="game-over">
    <h2>Game Over</h2>
    <div id="final-score"></div>
    <button onclick="restartGame()">Play Again</button>
  </div>

  <script>
    // Constants
    const GRID_SIZE = 30;
    const CELL_SIZE = 20;
    const INITIAL_SPEED = 150;
    const SPEED_INCREMENT = 10;
    const BOOST_MULTIPLIER = 3;

    // Directions
    const DIR = {
      UP: { x: 0, y: -1 },
      DOWN: { x: 0, y: 1 },
      LEFT: { x: -1, y: 0 },
      RIGHT: { x: 1, y: 0 }
    };

    // Game State Module
    function createGameState() {
      let state = {
        snake: [{ x: 15, y: 15 }],
        direction: DIR.RIGHT,
        nextDirection: DIR.RIGHT,
        food: null,
        score: 0,
        highScore: 0,
        speed: 1,
        gameOver: false,
        isPaused: false,
        isBoosting: false
      };

      function randomPosition() {
        return {
          x: Math.floor(Math.random() * GRID_SIZE),
          y: Math.floor(Math.random() * GRID_SIZE)
        };
      }

      function spawnFood() {
        let newFood;
        let attempts = 0;
        do {
          newFood = randomPosition();
          attempts++;
        } while (attempts < 100 && state.snake.some(seg => seg.x === newFood.x && seg.y === newFood.y));

        state.food = newFood;
      }

      function saveState() {
        localStorage.setItem('snake-high-score', state.highScore.toString());
      }

      function loadHighScore() {
        const saved = localStorage.getItem('snake-high-score');
        if (saved) {
          state.highScore = parseInt(saved, 10) || 0;
        }
      }

      return {
        init() {
          loadHighScore();
          state.snake = [{ x: 15, y: 15 }];
          state.direction = DIR.RIGHT;
          state.nextDirection = DIR.RIGHT;
          state.score = 0;
          state.speed = 1;
          state.gameOver = false;
          state.isPaused = false;
          state.isBoosting = false;
          spawnFood();
        },

        setDirection(dir) {
          // Prevent 180-degree turns
          if (dir.x === -state.direction.x && dir.y === -state.direction.y) {
            return;
          }
          state.nextDirection = dir;
        },

        setBoost(boosting) {
          state.isBoosting = boosting;
        },

        update() {
          if (state.gameOver || state.isPaused) return;

          state.direction = state.nextDirection;

          const head = state.snake[0];
          const newHead = {
            x: head.x + state.direction.x,
            y: head.y + state.direction.y
          };

          // Check wall collision
          if (newHead.x < 0 || newHead.x >= GRID_SIZE ||
              newHead.y < 0 || newHead.y >= GRID_SIZE) {
            state.gameOver = true;
            return;
          }

          // Check self collision
          if (state.snake.some(seg => seg.x === newHead.x && seg.y === newHead.y)) {
            state.gameOver = true;
            return;
          }

          state.snake.unshift(newHead);

          // Check food collision
          if (newHead.x === state.food.x && newHead.y === state.food.y) {
            state.score += 10;
            state.speed = Math.floor(state.score / 50) + 1;

            if (state.score > state.highScore) {
              state.highScore = state.score;
              saveState();
            }

            spawnFood();
          } else {
            state.snake.pop();
          }
        },

        togglePause() {
          state.isPaused = !state.isPaused;
          const pauseOverlay = document.getElementById('pause-overlay');
          pauseOverlay.style.display = state.isPaused ? 'block' : 'none';
        },

        getState() {
          return state;
        },

        getCurrentSpeed() {
          const baseSpeed = Math.max(50, INITIAL_SPEED - (state.speed - 1) * SPEED_INCREMENT);
          return state.isBoosting ? baseSpeed / BOOST_MULTIPLIER : baseSpeed;
        }
      };
    }

    // Renderer Module
    function createRenderer(canvas, gameState) {
      const ctx = canvas.getContext('2d');

      function drawCell(x, y, color) {
        ctx.fillStyle = color;
        ctx.fillRect(x * CELL_SIZE, y * CELL_SIZE, CELL_SIZE - 1, CELL_SIZE - 1);
      }

      return {
        clear() {
          ctx.fillStyle = '#000';
          ctx.fillRect(0, 0, canvas.width, canvas.height);
        },

        draw() {
          this.clear();
          const state = gameState.getState();

          // Draw food
          if (state.food) {
            drawCell(state.food.x, state.food.y, '#e74c3c');
          }

          // Draw snake
          state.snake.forEach((seg, index) => {
            const color = index === 0 ? '#2ecc71' : '#27ae60';
            drawCell(seg.x, seg.y, color);
          });
        },

        updateScore() {
          const state = gameState.getState();
          document.getElementById('score').textContent = `Score: ${state.score}`;
          document.getElementById('high-score').textContent = `High Score: ${state.highScore}`;
          document.getElementById('speed').textContent = `Speed: ${state.speed}`;
        }
      };
    }

    // Input Handler
    function createInputHandler(gameState, restartCallback) {
      let keysPressed = new Set();

      function handleKeyDown(e) {
        keysPressed.add(e.key);

        // Restart always works
        if (e.key === 'r' || e.key === 'R') {
          e.preventDefault();
          if (restartCallback) {
            restartCallback();
          }
          return;
        }

        // Pause/unpause always works
        if (e.key === 'p' || e.key === 'P' || e.key === 'Escape') {
          e.preventDefault();
          gameState.togglePause();
          return;
        }

        // Block other inputs if paused
        const state = gameState.getState();
        if (state.isPaused) {
          return;
        }

        const keyMap = {
          'ArrowLeft': () => gameState.setDirection(DIR.LEFT),
          'ArrowRight': () => gameState.setDirection(DIR.RIGHT),
          'ArrowUp': () => gameState.setDirection(DIR.UP),
          'ArrowDown': () => gameState.setDirection(DIR.DOWN),
          ' ': () => {
            e.preventDefault();
            gameState.setBoost(true);
          }
        };

        if (keyMap[e.key]) {
          if (e.key !== ' ') e.preventDefault();
          keyMap[e.key]();
        }
      }

      function handleKeyUp(e) {
        keysPressed.delete(e.key);

        if (e.key === ' ') {
          gameState.setBoost(false);
        }
      }

      return {
        bindKeys() {
          document.addEventListener('keydown', handleKeyDown);
          document.addEventListener('keyup', handleKeyUp);
        },

        unbindKeys() {
          document.removeEventListener('keydown', handleKeyDown);
          document.removeEventListener('keyup', handleKeyUp);
        }
      };
    }

    // Game initialization
    const canvas = document.getElementById('board');
    const gameState = createGameState();
    const renderer = createRenderer(canvas, gameState);
    const inputHandler = createInputHandler(gameState, restartGame);

    let lastTime = 0;
    let accumulator = 0;

    function gameLoop(timestamp) {
      const state = gameState.getState();

      renderer.draw();
      renderer.updateScore();

      if (state.gameOver) {
        showGameOver(state.score);
        return;
      }

      if (!state.isPaused) {
        const deltaTime = timestamp - lastTime;
        lastTime = timestamp;
        accumulator += deltaTime;

        const updateInterval = gameState.getCurrentSpeed();

        if (accumulator >= updateInterval) {
          gameState.update();
          accumulator = 0;
        }
      }

      requestAnimationFrame(gameLoop);
    }

    function showGameOver(score) {
      const gameOverDiv = document.getElementById('game-over');
      const finalScoreDiv = document.getElementById('final-score');
      finalScoreDiv.textContent = `Final Score: ${score}`;
      gameOverDiv.style.display = 'block';
    }

    function restartGame() {
      document.getElementById('game-over').style.display = 'none';
      document.getElementById('pause-overlay').style.display = 'none';
      gameState.init();
      lastTime = 0;
      accumulator = 0;
      requestAnimationFrame(gameLoop);
    }

    // Start the game
    inputHandler.bindKeys();
    gameState.init();
    requestAnimationFrame(gameLoop);
  </script>
</body>
</html>
